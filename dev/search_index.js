var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Peggy","category":"page"},{"location":"#Peggy","page":"Home","title":"Peggy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Packrat parser combinators for Julia supporting left-recursive grammars.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pretty good error messages","category":"page"},{"location":"","page":"Home","title":"Home","text":"pretty good syntax error messages. [TODO: how costly is this? Make it optional?]\ndetects and correctly handles left-recursion\nseparation of syntax from functinality.  I'm still playing around with the input syntax.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"#Creating-Parsers","page":"Home","title":"Creating Parsers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use @grammar to construct parsers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Peggy\n\njulia> p = @grammar begin\n          start = \"match a\"\n       end;\n\njulia> runpeg(p, \"match abc\") # does not need to match the entire string\n\"match a\"\n\njulia> p = @grammar begin\n          start = [ a_or_bs \" \"... hexdigit !anych() ]\n          a_or_bs = (\"a\" / \"b\")...\n          hexdigit = anych(\"[:digit:]a-fA-F\")\n       end;\n\njulia> p(\"abaab 9\")\n(a_or_bs = [\"a\", \"b\", \"a\", \"a\", \"b\"], hexdigit = \"9\")","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Peggy]","category":"page"},{"location":"#Peggy.END","page":"Home","title":"Peggy.END","text":"A PEG parser that matches the end of the input; yields result ().\n\n\n\n\n\n","category":"constant"},{"location":"#Peggy.NonemptyRegex","page":"Home","title":"Peggy.NonemptyRegex","text":"Succeeds with a non-empty value.\n\n\n\n\n\n","category":"type"},{"location":"#Peggy.Parser-Tuple{Any}","page":"Home","title":"Peggy.Parser","text":"(parser::Parser)(input)\n\nParsers are callable.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.anych-Tuple{String}","page":"Home","title":"Peggy.anych","text":"anych(charclass::String)\n\nCreate a parser for a single character matchng regex character classes. \n\nFunctionally identical to Regex(\"[charclass]\") except it is known to never match an empty string.  This is important to avoid unneccesary and expensive left-recursion overhead.\n\nExamples\n\njulia> g = @grammar begin\n       number = [ digit ds:(digit...)  { parse(Int, *(digit, ds...)) } ]\n       digit = anych(\"[:digit:]\")\n       end;\n\njulia> g(\"1234\")\n1234\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.anych-Tuple{}","page":"Home","title":"Peggy.anych","text":"A parser that matches any single character.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.grammar-Tuple{Symbol, Vararg{Pair{Symbol}}}","page":"Home","title":"Peggy.grammar","text":"grammar([start::Symbol], (symbol => peg_expr)...)\n\nCreate a parser from a set of productions, which are named, mutually recursive parsers.  \n\nParsers that are members of a grammar can reference are member parser by their symbol.\n\nIf start is omitted, the symbol of the first production is used.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.many-Tuple","page":"Home","title":"Peggy.many","text":"many(pegexpr...)\n\nCreate a parser that matches zero or more repititions of parser(pegexpr); return a vector of results.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.not-Tuple{Any}","page":"Home","title":"Peggy.not","text":"not(p)\n\nCreate a parser that fails if parser p succeeds. Otherwise it succeeds with value ()\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.oneof-Tuple","page":"Home","title":"Peggy.oneof","text":"oneof(pegexpr...)\n\nCreate a parser for ordered alternatives.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.pegparser-Tuple{AbstractString}","page":"Home","title":"Peggy.pegparser","text":"pegparser(peg_expr)\n\nCreate a Parser from a PEG expression.\n\nPEG Expressions\n\n- `String` - matches & yields the string literal\n- `Regex` - matches the  `Regex` and yields the match value\n- `Symbol` - matches to expression associated with the symbol in a `grammar`.\n- `[peg_expr...]` - matches the each expression in sequence. Yield a tuple of the result\n- `peg_exr...` - short-hand for the above, where syntatically valid.\n- `peg_expr => callable` - matches `peg_expr` and yields result of applying `callable` to its value.\n- `peg_epxr => k` - short-hand for `peg_expr` => _ -> k`\n- `Parser` - the result of `onoeof`, etc.\n\nSee also\n\nAny PEG parser is also a valid PEG expression There are a few other combinators that generate PEG parsers.\n\n- [`oneof(peg_expr...)`](@ref) - yields value of the first matching `peg_epxr`\n- [`many(peg_expr)`](@ref) - matches zero or more, yields a `AbstractVector` of the results\n- [`not(peg_expr)`](@ref) - matches only if `peg_epxr` fails. Yields `()`\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.runpeg-Tuple{Parser, AbstractString}","page":"Home","title":"Peggy.runpeg","text":"runpeg(e::Parser, s::AbstractString) => result_value\n\nParse the input with the parser.\n\nReturns the resulting value or throws a ParseException.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.@grammar-Tuple{Any}","page":"Home","title":"Peggy.@grammar","text":"Create a PEG parser from grammar expression.\n\n@grammar begin\n    grammar_expression = peg_expression\n    peg_expression = [\n        literal / regex_character_class\n    ]\n    regex_character_class = anych(\"[:alpha:]_\") \n    literal = \"an string\"\nend;\n\n\n\n\n\n","category":"macro"}]
}
