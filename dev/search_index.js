var documenterSearchIndex = {"docs":
[{"location":"expressions/#Peggy-expresions","page":"Expressions","title":"Peggy expresions","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Use @peg to create a parser.  You can also use the underly constructor functions which is occasionally useful.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"All examples assume you have installed Peggy.jl and loaded the package with","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> using Peggy","category":"page"},{"location":"expressions/#End-of-string","page":"Expressions","title":"End of string","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Matches the end of the input string. Consumes nothing, returns ().","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> ( END() )(\"\")\n()\n\njulia> ( END() )(\"something\")\nERROR: ParseException @ (no file):1:1\nsomething\n^\nexpected: END()\n[...]","category":"page"},{"location":"expressions/#String-literal","page":"Expressions","title":"String literal","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Matches a literal string and returns the string.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia>  (@peg { \"hello\" \"Peggy\" })( \"hello Peggy!\" )\n(\"hello\", \"Peggy\")","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"By default, trailing whitespace is ignored. You can alter this behavior with the lower-level peggy function: You can change the default trailing whitespace:","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> (@peg { peggy(\"a\"; skiptrailing=r\"\") \"b\"  })( \"a b\" )\nERROR: ParseException @ (no file):1:2\na b\n ^\nexpected: \"b\"\n[...]","category":"page"},{"location":"expressions/#Repetition-and-Optionality","page":"Expressions","title":"Repetition and Optionality","text":"","category":"section"},{"location":"expressions/#N-or-more-repitions","page":"Expressions","title":"N or more repitions","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> ( @peg \"a\"*2 )( \"aa\" )\n2-element Vector{String}:\n \"a\"\n \"a\"\n\njulia> ( @peg \"a\"*2 )( \"a\" )\nERROR: ParseException @ (no file):1:2\na\n ^\nexpected: \"a\"\n[...]","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> (@peg { \"a\"*(1:2) })( \"aaaab\" ) \n2-element Vector{String}:\n \"a\"\n \"a\"\n\njulia> (@peg { \"a\"*(1:2) })( \"ab\" ) \n1-element Vector{String}:\n \"a\"\n\njulia> (@peg { \"a\"*(2:3) })( \"ab\" ) \nERROR: ParseException @ (no file):1:2\nab\n ^\nexpected: \"a\"\n[...]","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Sugar:","category":"page"},{"location":"expressions/#Sequence","page":"Expressions","title":"Sequence","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> (@peg { \"a\"*_ \"b\" END() })( \"aaab\" ) \n([\"a\", \"a\", \"a\"], \"b\", ())","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> (@peg { result=\"a\"*_ \"b\" END() })( \"aaab\" ) \n3-element Vector{String}:\n \"a\"\n \"a\"\n \"a\"","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> (@peg { as=\"a\"*_ \"b\" END()  :> { length(as) }})( \"aaab\" ) \n3","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> (@peg { as=\"a\"*_ \"b\" END()  :> length })( \"aaab\" ) \n3","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"warning: Squirrely Curly\nJulia's parsing of curly-braces is mostly the same as for square-brackets.  But it has a strange interaction with unary operators.","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> Meta.show_sexpr(:( !{ a } ))\n(:curly, :!, :a)\njulia> Meta.show_sexpr(:( ![ a ] ))\n(:call, :!, (:vect, :a))","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"Use parentheses to avoid problems:","category":"page"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> Meta.show_sexpr(:( !({ a }) ))\n(:call, :!, (:braces, :a))","category":"page"},{"location":"expressions/#Character-class","page":"Expressions","title":"Character class","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"julia> ( @peg CHAR(\"[:alpha:]_\")*0  )( \"böse_7734!\" )\n5-element Vector{SubString{String}}:\n \"b\"\n \"ö\"\n \"s\"\n \"e\"\n \"_\"","category":"page"},{"location":"expressions/#Regular-Expressions","page":"Expressions","title":"Regular Expressions","text":"","category":"section"},{"location":"expressions/","page":"Expressions","title":"Expressions","text":"note: Regular expressions can kill performance.\nBy default, r\"[[:space:]*\" is translated to Peggy.GeneralRegexParser(\"[[:space:]]*\") because Peggy assumes the expression can match an empty string.  That assumption may cause a rule to be deemed left-recursive, which has some overhead.  If you know your expression does not match \"\", you can use Peggy.NonemptyRegx.   For example, Peggy's PCRE class express :[\"[:space]\"] expands to `Peggy.NonemptyRegex(\"[[:scpace]]\").","category":"page"},{"location":"expressions/#Peggy-functions","page":"Expressions","title":"Peggy functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Peggy\nusing Peggy","category":"page"},{"location":"#Peggy","page":"Home","title":"Peggy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generate Packrat PEG parsers for Julia ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pretty good syntax error messages. \ndetects and correctly handles left-recursion\nboth combinator functions and a macro are provided","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Peggy.Parser is function that takes a string as input and returns its parsed value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create parsers using either a succinct Peggy expression via the @peg macro or lower-level functions.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Peggy]","category":"page"},{"location":"#Peggy.NonemptyRegex","page":"Home","title":"Peggy.NonemptyRegex","text":"Succeeds with a non-empty value.\n\n\n\n\n\n","category":"type"},{"location":"#Peggy.Parser","page":"Home","title":"Peggy.Parser","text":"(parser::Parser)(input)\n\nA Peggy.Parser is function that takes a string as input and returns its parsed value.\n\n\n\n\n\n","category":"type"},{"location":"#Peggy.fail","page":"Home","title":"Peggy.fail","text":"\n\n\n\n","category":"type"},{"location":"#Peggy.ANY-Tuple{}","page":"Home","title":"Peggy.ANY","text":"A PEG parser that matches any character and yields it as a string.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.CHAR-Tuple{String}","page":"Home","title":"Peggy.CHAR","text":"CHAR(charclass::String)\n\nCreate a parser for a single character matchng regex character classes. \n\nFunctionally identical to Regex(\"[charclass]\") except it is known to never match an empty string.  This is important to avoid unneccesary and expensive left-recursion overhead.\n\nExamples\n\njulia> g = @grammar begin\n       number = [ digit ds:(digit...)  { parse(Int, *(digit, ds...)) } ]\n       digit = CHAR(\"[:digit:]\")\n       end;\n\njulia> g(\"1234\")\n1234\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.END-Tuple{}","page":"Home","title":"Peggy.END","text":"A PEG parser that matches the end of the input; yields result ().\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.grammar-Tuple{Symbol, Vararg{Pair{Symbol}}}","page":"Home","title":"Peggy.grammar","text":"grammar([start::Symbol], (symbol => peg_expr)...)\n\nCreate a parser from a set of productions, which are named, mutually recursive parsers.  \n\nParsers that are members of a grammar can reference are member parser by their symbol.\n\nIf start is omitted, the symbol of the first production is used.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.many-Tuple","page":"Home","title":"Peggy.many","text":"many(exprs...; min=0, max=missing)\n\nCreate a parser that matches zero or more repititions of the sequence expr...; returns a vector of results.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.not-Tuple{Any}","page":"Home","title":"Peggy.not","text":"not(p)\n\nCreate a parser that fails if parser p succeeds. Otherwise it succeeds with value ()\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.oneof-Tuple","page":"Home","title":"Peggy.oneof","text":"oneof(pegexpr...)\n\nCreate a parser for ordered alternatives.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.pegparser-Tuple{AbstractString}","page":"Home","title":"Peggy.pegparser","text":"pegparser(peg_expr)\n\nCreate a Parser from a PEG expression.\n\nPEG Expressions\n\n- `String` - matches & yields the string literal\n- `Regex` - matches the  `Regex` and yields the match value\n- `Symbol` - matches to expression associated with the symbol in a `grammar`.\n- `[peg_expr...]` - matches the each expression in sequence. Yield a tuple of the result\n- `peg_exr...` - short-hand for the above, where syntatically valid.\n- `peg_expr => callable` - matches `peg_expr` and yields result of applying `callable` to its value.\n- `peg_epxr => k` - short-hand for `peg_expr` => _ -> k`\n- `Parser` - the result of `onoeof`, etc.\n\nSee also\n\nAny PEG parser is also a valid PEG expression There are a few other combinators that generate PEG parsers.\n\n- [`oneof(peg_expr...)`](@ref) - yields value of the first matching `peg_epxr`\n- [`many(peg_expr)`](@ref) - matches zero or more, yields a `AbstractVector` of the results\n- [`not(peg_expr)`](@ref) - matches only if `peg_epxr` fails. Yields `()`\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.runpeg-Tuple{Parser, AbstractString}","page":"Home","title":"Peggy.runpeg","text":"runpeg(e::Parser, s::AbstractString) => result_value\n\nParse the input with the parser.\n\nReturns the resulting value or throws a ParseException.\n\n\n\n\n\n","category":"method"},{"location":"#Peggy.@peg-Tuple{Any}","page":"Home","title":"Peggy.@peg","text":"Create a Peggy.Parser from a Peggy expression\n\n\n\n\n\n","category":"macro"}]
}
